# 编译时元编程与类型系统

**摘要**: 本文档阐述了 Flurry 编程语言的核心设计——一个深度集成的编译时元编程与类型系统。Flurry 旨在通过一个统一的、基于两级类型论和一阶逻辑的框架，在提供极致性能和底层控制力的同时，赋予开发者前所未有的静态保证和抽象能力。本文档将系统地介绍 Flurry 的核心概念，包括两级类型论、泛型的函数式诠释、可选子句参数、Normalization 与 Instantiation 的两阶段编译模型，以及一个由可达性逻辑驱动的、用户可扩展的静态分析基础设施。

## 1. 核心哲学：从“编译技巧”到“类型理论”

现代系统编程语言在追求零开销抽象时，普遍依赖于各种形式的编译期元编程。然而，这些系统往往是作为语言的“特殊功能”存在的，缺乏统一的理论基础，导致了复杂的规则、难以理解的错误信息和不一致的语义（例如 C++ 的模板元编程和 Zig 的 `comptime`）。

Flurry 的设计哲学与之截然不同。它不将元编程视为一种“技巧”，而是将其作为语言类型系统**内在的、核心的一部分**。其所有编译时特性，都源于一个统一且严谨的理论基础。

**核心原则**:
1.  **元编程即类型论 (Metaprogramming as Type Theory)**: 所有泛型、编译时函数和类型级别的计算，都被统一建模为有严格理论定义的**纯粹的编译期高阶函数**。
2.  **安全性由构造保证 (Safety by Construction)**: 通过一个强大的、基于逻辑推理的类型检查器，尽可能在**定义端 (Definition-site)** 就保证代码的内部逻辑自洽性，而不是将所有错误推迟到调用端。
3.  **显式与可控 (Explicit and Controlled)**: 语言的设计引导程序员清晰地思考和声明代码的**编译期/运行时边界**、**依赖**和**副作用**，避免隐式的“魔法”。

## 2. 理论基石：两级类型论 (2LTT)

Flurry 的世界被严格划分为两个层级，其交互由两级类型论 (Two-Level Type Theory) 的原则所约束。

*   **编译期宇宙 (`U₁`) 与上下文 (`C₁`)**: 这是由 Flurry 编译器自身执行的领域。所有类型 (`Type`)、范式 (`for<...>`)、`comptime` 函数和代码块、以及 `inline` 控制流的条件，都存在于此。计算结果直接影响最终生成的代码，且没有运行时开销。`Type` 在 `U₁` 中是一等公民。

*   **运行时宇宙 (`U₀`) 与上下文 (`C₀`)**: 这是程序最终被编译并在目标机器上执行的领域，包含了所有常规的函数和逻辑。

这两个宇宙通过三个核心操作进行交互（在 Flurry 中通常是隐式的）：

*   **Lift (提升)**: 将一个运行时类型（`U₀`）的概念提升为一个可在编译期 (`U₁`) 操纵的 `Type` 实体。
*   **Quote (引用)**: 将一段运行时代码 (`U₀`) 包装成一个可在编译期 (`U₁`) 分析的抽象语法树（AST）或类似的数据结构。
*   **Splice (拼接)**: **Flurry 零开销抽象的来源**。它在编译期执行一个 `U₁` 表达式，并将结果（一个值或一段代码）无缝地、零开销地**嵌入**到运行时代码 (`U₀`) 中。

这一理论框架保证了所有元编程操作的类型安全：如果一个元程序（在 `U₁`）是类型正确的，那么它生成的代码（在 `U₀`）也必然是类型正确的。

## 3. 泛型与元编程的统一范式

Flurry 抛弃了传统的“泛型模板”概念，将其统一为**返回函数的编译期函数**。

*   **范式 (`for<...>` / `pure comptime fn<...>`)**: 这是 Flurry 元编程的原子构造。`for<T> Type` 是 `pure comptime fn<T: Type> -> Type` 的语法糖。

*   **泛型即函数**: 一个泛型结构体，如 `struct Vec where T`，在 Flurry 的核心语言中被去糖（desugar）为一个编译期函数：
    ```flurry
    pure comptime fn Vec<T: Type> -> Type {
        return struct { /* ... fields using T ... */ };
    }
    ```

*   **柯里化与部分应用**:
    *   **子句参数 (`<...>`)** 和 **运行时参数 (`(...)`)** 并非两种不同的机制，而是**函数柯里化（Currying）**的统一语法表现。
    *   `merge<T, m, n>` 是对 `merge` 这个编译期高阶函数的一次**部分应用（Partial Application）**，其结果是一个具体的、非泛型的运行时函数。
    *   这使得参数推导成为一种自然的、基于类型反向求解的过程，而不是编译器的特殊魔法。
    ```flurry
    -- merge 是一个返回函数的编译期函数
    const my_i32_merge: fn(...) = merge<i32, 8, 8>; -- 编译期部分应用
    ```

## 4. 两阶段编译模型：Normalization vs. Instantiation

为了兼顾定义端的健壮性和调用端的灵活性，Flurry 的编译器采用一个清晰的两阶段分析模型。

### 4.1. Normalization (定义期检查)

*   **时机**: 在编译器首次解析一个（可能是泛型的）定义时。
*   **目标**: 验证该定义的**内部逻辑自洽性**，而不依赖任何具体的实例化类型。
*   **核心任务**:
    1.  **约束满足性检查**: 验证函数体内的操作，是否能被其签名的 `where` 子句提供的约束所满足。
    2.  **编译期控制流分析**: 通过**符号执行**遍历 `inline if`/`inline when` 的所有分支，确保每个分支在**其自身的精化类型环境（Refined Type Environment）**下都是类型正确的。
    3.  **`impl` 候选集验证**: 对同一类型/trait 的多个 `implementation`，验证其 `requires` 子句是否**互斥**，防止未来的实例化产生歧义。

Normalization 失败意味着定义本身存在逻辑缺陷，错误会直接指向**定义处**。

### 4.2. Instantiation (调用期特化)

*   **时机**: 当一个泛型定义被具体参数调用时。
*   **目标**: 验证该**具体调用**的合法性，并生成特化后的代码。
*   **核心任务**:
    1.  **参数替换**: 将泛型参数替换为调用点提供的具体类型或值。
    2.  **编译期求值**: 对 `inline if` 等内联控制流的条件和 `where` 子句中的命题进行**具体求值**。
    3.  **递归实例化**: 如果特化后的代码又调用了其他泛型实体，则递归地进行实例化。

Instantiation 失败意味着**调用方式**存在问题，错误会指向**调用点**，并提供完整的实例化回溯栈。

## 5. 可编程的静态分析框架

Flurry 的类型系统本身就是一个可编程的、基于一阶逻辑的静态分析框架。程序员通过声明式的语法，向编译器提供关于程序行为的**公理和定理**。

### 5.1. 类型命题逻辑

Flurry 的 `requires` 子句支持丰富的逻辑命题，远超简单的 trait bound。

*   **基础命题**: `t: T` (类型), `T:- A` (Trait), `T == U` (相等), `T matches Array<Any, any>` (结构匹配)。
*   **逻辑连接词**: `and`, `or`, `not`, `==>`。
*   **非类型谓语**: 命题可以不直接引用编译环境，如 `build.mode == .debug`。

### 5.2. Occurrence Typing

`inline when`、`inline if` 等等内联控制流是连接命题逻辑和代码生成的桥梁。它在 Normalization 阶段验证代码的可用性，
每个分支的条件都会向该分支内部传递**更强的类型谓词**，或者说类型约束，从而精化类型环境。

```flurry
fn show(data: T) -> String where T {
    inline when {
        -- 在此分支内, 编译器可以假定 T 实现了 Display
        T:- Display => fmt.format("{}", data),
        -- 在此分支内, 编译器可以假定 T 有一个 to_string 方法
        T:~ to_string : fn(*itself) => data.to_string(),
        _ => ...
    }
}
```

## 6. 编译期副作用与上下文信息的安全处理

直接在 `where` 子句或 `pure comptime fn` 中进行有副作用的编译期计算（如 I/O 或访问不确定的编译环境）会破坏纯粹性和可缓存性。Flurry 通过**可选子句参数**优雅地解决了这个问题。

```flurry
fn my_func()
where .feature_enabled: bool = build.features.enabled(.some_feature),
      .src_span: SrcSpan = meta.compiler.src.get_span()
{
    inline if not feature_enabled {
        meta.compile_error("This function is not available while the feature is disabled.");
    }
    println("Called at $src_span");
}
```
```log
Error[...]: Comptime panics during instantiation
    ╭─[ src/manbo/mod.fl:23:5 ]
    │
 22 │     do_something();
 23 │     my_func();
    │     ^^^^^^^^^^ This function is not available while the feature is disabled.
 24 │     return;
    ╰───
```

*   **参数化副作用**: 不纯的、依赖调用端状态的计算被隔离在**参数的默认值生成器**中。
*   **保持纯粹性**: 函数体本身只依赖于**纯粹的输入参数**（`feature_enabled`, `src_span`），因此 `my_func` 作为一个 `pure comptime fn` 的实例是可被安全缓存的。
*   **统一接口**: 无论是传递外部配置，还是获取编译器内部的上下文信息，都通过这一统一、显式的语法完成。

## 7. 结论

Flurry 的编译时元编程与类型系统是一个**深度统一、理论驱动**的系统。它通过**两级类型论**奠定基础，以**编译期高阶函数**统一泛型和元编程，通过**两阶段编译模型**平衡健壮性与灵活性，并最终提供了一个**可编程的、基于一阶逻辑的静态分析框架**。

这个设计旨在消除困扰现有系统语言的诸多设计妥协，为开发者提供一个既能进行最底层硬件操作，又能享受最高级别静态安全保证的、真正面向未来的编程工具。